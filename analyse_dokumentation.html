<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCA und Cluster-Analyse - Schweizer Abstimmungsdaten</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --bg-light: #f8f9fa;
            --code-bg: #1e1e1e;
            --code-text: #d4d4d4;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: white;
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
        }

        h1 {
            color: var(--primary);
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.2em;
        }

        .nav-links {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .nav-links a {
            display: inline-block;
            padding: 10px 25px;
            background: var(--secondary);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            transition: all 0.3s;
        }

        .nav-links a:hover {
            background: var(--primary);
            transform: translateY(-2px);
        }

        section {
            background: white;
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        }

        h2 {
            color: var(--primary);
            font-size: 1.8em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--secondary);
        }

        h3 {
            color: var(--secondary);
            font-size: 1.3em;
            margin: 25px 0 15px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .code-block {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .code-block .comment {
            color: #6a9955;
        }

        .code-block .keyword {
            color: #569cd6;
        }

        .code-block .string {
            color: #ce9178;
        }

        .code-block .function {
            color: #dcdcaa;
        }

        .code-block .number {
            color: #b5cea8;
        }

        .explanation {
            background: var(--bg-light);
            padding: 20px;
            border-left: 4px solid var(--secondary);
            border-radius: 0 10px 10px 0;
            margin: 20px 0;
        }

        .explanation-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .image-container {
            text-align: center;
            margin: 30px 0;
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }

        .image-caption {
            color: #666;
            font-style: italic;
            margin-top: 10px;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .image-grid img {
            width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: var(--primary);
            color: white;
        }

        tr:nth-child(even) {
            background: var(--bg-light);
        }

        tr:hover {
            background: #e8f4f8;
        }

        .highlight-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .highlight-box h4 {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .cluster-card {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .cluster {
            padding: 20px;
            border-radius: 10px;
            color: white;
        }

        .cluster-0 { background: #e41a1c; }
        .cluster-1 { background: #377eb8; }
        .cluster-2 { background: #4daf4a; }
        .cluster-3 { background: #984ea3; }

        .cluster h4 {
            margin-bottom: 10px;
        }

        .cluster ul {
            margin-left: 20px;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: white;
        }

        .toc {
            background: var(--bg-light);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .toc h3 {
            margin-top: 0;
        }

        .toc ul {
            list-style: none;
            padding-left: 0;
        }

        .toc li {
            margin: 8px 0;
        }

        .toc a {
            color: var(--secondary);
            text-decoration: none;
        }

        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>PCA und Cluster-Analyse</h1>
            <p class="subtitle">Statistische Analyse von Schweizer Abstimmungsdaten (2000-2025)</p>
            <div class="nav-links">
                <a href="3_PCA/pca_analysis.ipynb">PCA Notebook</a>
                <a href="4_Cluster/cluster_analysis.ipynb">Cluster Notebook</a>
                <a href="4_Cluster/cluster_on_pca.ipynb">Cluster auf PCA</a>
                <a href="4_Cluster/cluster_visualization.ipynb">Visualisierungen</a>
            </div>
        </header>

        <section>
            <div class="toc">
                <h3>Inhaltsverzeichnis</h3>
                <ul>
                    <li><a href="#pca-intro">1. Einleitung zur PCA</a></li>
                    <li><a href="#pca-data">2. Datenvorbereitung</a></li>
                    <li><a href="#pca-analysis">3. PCA-Durchfuehrung</a></li>
                    <li><a href="#pca-interpretation">4. Interpretation der Dimensionen</a></li>
                    <li><a href="#cluster-intro">5. Cluster-Analyse</a></li>
                    <li><a href="#cluster-methods">6. Clustering-Methoden</a></li>
                    <li><a href="#cluster-pca">7. Verbessertes Clustering auf PCA-Scores</a></li>
                    <li><a href="#cluster-results">8. Ergebnisse und Visualisierungen</a></li>
                </ul>
            </div>
        </section>

        <!-- PCA SECTION -->
        <section id="pca-intro">
            <h2>1. Einleitung zur Hauptkomponentenanalyse (PCA)</h2>
            <p>
                Die Hauptkomponentenanalyse (Principal Component Analysis, PCA) ist ein statistisches Verfahren
                zur Dimensionsreduktion. Bei unseren Abstimmungsdaten haben wir 223 Vorlagen, die wir auf wenige
                interpretierbare Dimensionen reduzieren moechten.
            </p>
            <p>
                Basierend auf der Forschung von Hermann & Leuthold erwarten wir drei wesentliche Dimensionen:
            </p>
            <ul>
                <li><strong>PC1:</strong> Rechts vs. Links (wirtschaftlich)</li>
                <li><strong>PC2:</strong> Konservativ vs. Liberal (gesellschaftlich)</li>
                <li><strong>PC3:</strong> Technokratisch vs. Oekologisch</li>
            </ul>
        </section>

        <section id="pca-data">
            <h2>2. Datenvorbereitung</h2>

            <h3>2.1 Daten laden aus SQLite</h3>
            <div class="code-block">
<span class="keyword">import</span> sqlite3
<span class="keyword">import</span> pandas <span class="keyword">as</span> pd
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler
<span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer

<span class="comment"># Verbindung zur Datenbank</span>
conn = sqlite3.<span class="function">connect</span>(<span class="string">'../data/processed/swiss_votings.db'</span>)

<span class="comment"># Abstimmungsdaten laden (mit Gemeinde-Fusionen korrigiert)</span>
query = <span class="string">"""
    SELECT
        municipality_id,
        municipality_name,
        proposal_id,
        ja_prozent
    FROM v_voting_results_analysis
    WHERE ja_prozent IS NOT NULL
"""</span>
df = pd.<span class="function">read_sql_query</span>(query, conn)
<span class="function">print</span>(f<span class="string">"Geladen: {len(df):,} Datensaetze"</span>)
            </div>

            <div class="explanation">
                <div class="explanation-title">Erklaerung:</div>
                <p>
                    Wir verwenden die View <code>v_voting_results_analysis</code>, die bereits Gemeinde-Fusionen
                    beruecksichtigt. So werden historische Gemeinden korrekt auf ihre heutigen Nachfolger gemappt.
                    Die Variable <code>ja_prozent</code> gibt den Ja-Stimmenanteil pro Gemeinde und Vorlage an.
                </p>
            </div>

            <h3>2.2 Pivot-Matrix erstellen</h3>
            <div class="code-block">
<span class="comment"># Pivot: Gemeinden x Vorlagen Matrix</span>
vote_matrix = df.<span class="function">pivot_table</span>(
    index=[<span class="string">'municipality_id'</span>, <span class="string">'municipality_name'</span>],
    columns=<span class="string">'proposal_id'</span>,
    values=<span class="string">'ja_prozent'</span>,
    aggfunc=<span class="string">'mean'</span>
)

<span class="function">print</span>(f<span class="string">"Matrix-Dimensionen: {vote_matrix.shape}"</span>)
<span class="comment"># Output: Matrix-Dimensionen: (2109, 223)</span>
            </div>

            <div class="explanation">
                <div class="explanation-title">Erklaerung:</div>
                <p>
                    Die Pivot-Tabelle transformiert die Daten in eine Matrix mit 2'109 Gemeinden (Zeilen)
                    und 223 Abstimmungsvorlagen (Spalten). Jede Zelle enthaelt den Ja-Stimmenanteil (0-100%).
                </p>
            </div>

            <h3>2.3 Fehlende Werte behandeln</h3>
            <div class="code-block">
<span class="comment"># Analyse fehlender Werte pro Vorlage</span>
missing_pct = vote_matrix.<span class="function">isnull</span>().<span class="function">sum</span>() / <span class="function">len</span>(vote_matrix) * <span class="number">100</span>

<span class="comment"># Vorlagen mit >20% fehlenden Werten ausschliessen</span>
valid_columns = missing_pct[missing_pct <= <span class="number">20</span>].index
vote_matrix_filtered = vote_matrix[valid_columns]

<span class="comment"># Imputation: Fehlende Werte mit Spaltenmittelwert ersetzen</span>
imputer = <span class="function">SimpleImputer</span>(strategy=<span class="string">'mean'</span>)
vote_matrix_imputed = pd.<span class="function">DataFrame</span>(
    imputer.<span class="function">fit_transform</span>(vote_matrix_filtered),
    index=vote_matrix_filtered.index,
    columns=vote_matrix_filtered.columns
)

<span class="function">print</span>(f<span class="string">"Nach Filterung: {vote_matrix_imputed.shape}"</span>)
            </div>

            <div class="image-container">
                <img src="3_PCA/missing_values_analysis.png" alt="Analyse fehlender Werte">
                <p class="image-caption">Analyse der fehlenden Werte pro Abstimmungsvorlage</p>
            </div>

            <h3>2.4 Standardisierung</h3>
            <div class="code-block">
<span class="comment"># Z-Standardisierung (Mittelwert=0, Standardabweichung=1)</span>
scaler = <span class="function">StandardScaler</span>()
vote_matrix_scaled = scaler.<span class="function">fit_transform</span>(vote_matrix_imputed)

<span class="function">print</span>(f<span class="string">"Skalierte Matrix: {vote_matrix_scaled.shape}"</span>)
<span class="function">print</span>(f<span class="string">"Mittelwert (sollte ~0 sein): {vote_matrix_scaled.mean():.6f}"</span>)
<span class="function">print</span>(f<span class="string">"Std (sollte ~1 sein): {vote_matrix_scaled.std():.6f}"</span>)
            </div>

            <div class="explanation">
                <div class="explanation-title">Erklaerung:</div>
                <p>
                    Die Standardisierung ist essentiell fuer PCA, da die Methode sensitiv gegenueber
                    unterschiedlichen Skalierungen ist. Nach der Transformation hat jede Variable
                    Mittelwert 0 und Standardabweichung 1.
                </p>
            </div>
        </section>

        <section id="pca-analysis">
            <h2>3. PCA-Durchfuehrung</h2>

            <h3>3.1 PCA berechnen</h3>
            <div class="code-block">
<span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA

<span class="comment"># PCA mit allen Komponenten</span>
pca_full = <span class="function">PCA</span>()
pca_full.<span class="function">fit</span>(vote_matrix_scaled)

<span class="comment"># Erklaerte Varianz</span>
explained_var = pca_full.explained_variance_ratio_
cumulative_var = np.<span class="function">cumsum</span>(explained_var)

<span class="function">print</span>(<span class="string">"Erklaerte Varianz der ersten 5 Komponenten:"</span>)
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">5</span>):
    <span class="function">print</span>(f<span class="string">"  PC{i+1}: {explained_var[i]*100:.1f}% (kumulativ: {cumulative_var[i]*100:.1f}%)"</span>)
            </div>

            <div class="highlight-box">
                <h4>Erklaerte Varianz</h4>
                <table style="color: white; border-color: rgba(255,255,255,0.3);">
                    <tr><th>Komponente</th><th>Varianz</th><th>Kumulativ</th></tr>
                    <tr><td>PC1</td><td>35.9%</td><td>35.9%</td></tr>
                    <tr><td>PC2</td><td>14.1%</td><td>50.0%</td></tr>
                    <tr><td>PC3</td><td>9.0%</td><td>59.0%</td></tr>
                    <tr><td>PC4</td><td>4.1%</td><td>63.1%</td></tr>
                    <tr><td>PC5</td><td>2.8%</td><td>65.9%</td></tr>
                </table>
            </div>

            <h3>3.2 Scree-Plot und Eigenwerte</h3>
            <div class="code-block">
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

fig, axes = plt.<span class="function">subplots</span>(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">14</span>, <span class="number">5</span>))

<span class="comment"># Scree Plot</span>
axes[<span class="number">0</span>].<span class="function">plot</span>(<span class="function">range</span>(<span class="number">1</span>, <span class="number">21</span>), explained_var[:<span class="number">20</span>] * <span class="number">100</span>, <span class="string">'bo-'</span>)
axes[<span class="number">0</span>].<span class="function">set_xlabel</span>(<span class="string">'Hauptkomponente'</span>)
axes[<span class="number">0</span>].<span class="function">set_ylabel</span>(<span class="string">'Erklaerte Varianz (%)'</span>)
axes[<span class="number">0</span>].<span class="function">set_title</span>(<span class="string">'Scree Plot'</span>)
axes[<span class="number">0</span>].<span class="function">axhline</span>(y=<span class="number">5</span>, color=<span class="string">'r'</span>, linestyle=<span class="string">'--'</span>, label=<span class="string">'5% Schwelle'</span>)

<span class="comment"># Kumulative Varianz</span>
axes[<span class="number">1</span>].<span class="function">plot</span>(<span class="function">range</span>(<span class="number">1</span>, <span class="number">21</span>), cumulative_var[:<span class="number">20</span>] * <span class="number">100</span>, <span class="string">'go-'</span>)
axes[<span class="number">1</span>].<span class="function">axhline</span>(y=<span class="number">60</span>, color=<span class="string">'r'</span>, linestyle=<span class="string">'--'</span>)
axes[<span class="number">1</span>].<span class="function">set_xlabel</span>(<span class="string">'Anzahl Komponenten'</span>)
axes[<span class="number">1</span>].<span class="function">set_ylabel</span>(<span class="string">'Kumulative erklaerte Varianz (%)'</span>)
axes[<span class="number">1</span>].<span class="function">set_title</span>(<span class="string">'Kumulative Varianz'</span>)

plt.<span class="function">tight_layout</span>()
plt.<span class="function">savefig</span>(<span class="string">'scree_plot.png'</span>)
            </div>

            <div class="image-container">
                <img src="3_PCA/scree_plot.png" alt="Scree Plot">
                <p class="image-caption">Scree-Plot: Der "Knick" nach PC3 deutet auf 3 relevante Dimensionen hin</p>
            </div>

            <div class="explanation">
                <div class="explanation-title">Interpretation des Scree-Plots:</div>
                <p>
                    Der Scree-Plot zeigt einen deutlichen Abfall nach den ersten drei Komponenten.
                    Dies entspricht dem "Ellbogen-Kriterium" und bestaetigt die Wahl von 3 Hauptkomponenten.
                    Mit 3 Komponenten erklaeren wir bereits 59% der Gesamtvarianz - ein guter Wert fuer
                    Abstimmungsdaten mit ihrer inhaerent hohen Komplexitaet.
                </p>
            </div>

            <h3>3.3 PCA mit 3 Komponenten</h3>
            <div class="code-block">
<span class="comment"># Finale PCA mit 3 Komponenten</span>
pca = <span class="function">PCA</span>(n_components=<span class="number">3</span>)
pca_scores = pca.<span class="function">fit_transform</span>(vote_matrix_scaled)

<span class="comment"># Scores als DataFrame</span>
pca_df = pd.<span class="function">DataFrame</span>(
    pca_scores,
    columns=[<span class="string">'PC1'</span>, <span class="string">'PC2'</span>, <span class="string">'PC3'</span>],
    index=vote_matrix_imputed.index
)
pca_df = pca_df.<span class="function">reset_index</span>()

<span class="function">print</span>(pca_df.<span class="function">head</span>())
            </div>
        </section>

        <section id="pca-interpretation">
            <h2>4. Interpretation der Dimensionen</h2>

            <h3>4.1 Analyse der Ladungen</h3>
            <div class="code-block">
<span class="comment"># Ladungen (Korrelation zwischen Variablen und PCs)</span>
loadings = pd.<span class="function">DataFrame</span>(
    pca.components_.T,
    columns=[<span class="string">'PC1'</span>, <span class="string">'PC2'</span>, <span class="string">'PC3'</span>],
    index=vote_matrix_imputed.columns
)

<span class="comment"># Top-Ladungen fuer PC1</span>
<span class="function">print</span>(<span class="string">"PC1 - Hoechste positive Ladungen (KONSERVATIV):"</span>)
<span class="function">print</span>(loadings[<span class="string">'PC1'</span>].<span class="function">nlargest</span>(<span class="number">5</span>))

<span class="function">print</span>(<span class="string">"\nPC1 - Hoechste negative Ladungen (LIBERAL):"</span>)
<span class="function">print</span>(loadings[<span class="string">'PC1'</span>].<span class="function">nsmallest</span>(<span class="number">5</span>))
            </div>

            <div class="explanation">
                <div class="explanation-title">Interpretation der drei Dimensionen:</div>
                <p><strong>PC1: Rechts vs. Links (wirtschaftlich)</strong></p>
                <ul>
                    <li>Positive Werte (+): Links - staedtisch, progressiv, pro-Umverteilung</li>
                    <li>Negative Werte (-): Rechts - laendlich, traditionell, wirtschaftsliberal</li>
                    <li>Beispiel: Lausanne, Zuerich, Bern (links) vs. Muotathal, Schwyz (rechts)</li>
                </ul>

                <p><strong>PC2: Konservativ vs. Liberal (gesellschaftlich)</strong></p>
                <ul>
                    <li>Positive Werte (+): Liberal - gesellschaftlich offen</li>
                    <li>Negative Werte (-): Konservativ - gesellschaftlich traditionell</li>
                    <li>Beispiel: Zuerich, Zug (liberal) vs. Muotathal, Geneve (konservativ)</li>
                </ul>

                <p><strong>PC3: Technokratisch vs. Oekologisch</strong></p>
                <ul>
                    <li>Positive Werte (+): Oekologisch - Pro-Umwelt, erneuerbare Energien</li>
                    <li>Negative Werte (-): Technokratisch - Pro-Kernenergie, technische Loesungen</li>
                    <li>Beispiel: Bern, Zuerich (oekologisch) vs. Muotathal (technokratisch)</li>
                </ul>
            </div>

            <h3>4.2 Visualisierung der Gemeinden im PCA-Raum</h3>

            <div class="image-grid">
                <div>
                    <img src="3_PCA/pca_2d_scatter.png" alt="PCA 2D">
                    <p class="image-caption">PC1 vs PC2: Schweizer Gemeinden</p>
                </div>
                <div>
                    <img src="3_PCA/pca_3d_scatter.png" alt="PCA 3D">
                    <p class="image-caption">3D-Darstellung aller drei Komponenten</p>
                </div>
            </div>

        </section>

        <!-- CLUSTER SECTION -->
        <section id="cluster-intro">
            <h2>5. Cluster-Analyse</h2>
            <p>
                Die Cluster-Analyse gruppiert die 2'109 Schweizer Gemeinden basierend auf ihrem
                Abstimmungsverhalten. Wir vergleichen verschiedene Algorithmen und evaluieren
                die Ergebnisse mit etablierten Metriken.
            </p>

            <h3>Verwendete Metriken</h3>
            <table>
                <tr>
                    <th>Metrik</th>
                    <th>Bereich</th>
                    <th>Interpretation</th>
                </tr>
                <tr>
                    <td>Silhouette Score</td>
                    <td>-1 bis 1</td>
                    <td>Hoeher = bessere Trennung der Cluster</td>
                </tr>
                <tr>
                    <td>Calinski-Harabasz</td>
                    <td>0 bis &#8734;</td>
                    <td>Hoeher = dichtere, besser getrennte Cluster</td>
                </tr>
                <tr>
                    <td>Davies-Bouldin</td>
                    <td>0 bis &#8734;</td>
                    <td>Niedriger = bessere Trennung</td>
                </tr>
            </table>
        </section>

        <section id="cluster-methods">
            <h2>6. Clustering-Methoden im Vergleich</h2>

            <h3>6.1 K-Means Clustering</h3>
            <div class="code-block">
<span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans
<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> silhouette_score, calinski_harabasz_score

<span class="comment"># Optimale Cluster-Anzahl finden</span>
silhouette_scores = []
<span class="keyword">for</span> k <span class="keyword">in</span> <span class="function">range</span>(<span class="number">2</span>, <span class="number">11</span>):
    kmeans = <span class="function">KMeans</span>(n_clusters=k, random_state=<span class="number">42</span>, n_init=<span class="number">10</span>)
    labels = kmeans.<span class="function">fit_predict</span>(data)
    score = <span class="function">silhouette_score</span>(data, labels)
    silhouette_scores.<span class="function">append</span>(score)
    <span class="function">print</span>(f<span class="string">"k={k}: Silhouette={score:.3f}"</span>)

<span class="comment"># Bestes k waehlen</span>
best_k = silhouette_scores.<span class="function">index</span>(<span class="function">max</span>(silhouette_scores)) + <span class="number">2</span>
<span class="function">print</span>(f<span class="string">"\nOptimale Cluster-Anzahl: {best_k}"</span>)
            </div>

            <div class="explanation">
                <div class="explanation-title">K-Means Algorithmus:</div>
                <p>
                    K-Means partitioniert die Daten in k Cluster, indem iterativ Cluster-Zentren
                    (Zentroide) berechnet und Datenpunkte dem naechsten Zentrum zugewiesen werden.
                    Der Algorithmus minimiert die Within-Cluster Sum of Squares (WCSS).
                </p>
            </div>

            <h3>6.2 Hierarchisches Clustering</h3>
            <div class="code-block">
<span class="keyword">from</span> scipy.cluster.hierarchy <span class="keyword">import</span> dendrogram, linkage, fcluster
<span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering

<span class="comment"># Ward-Linkage (minimiert Varianz innerhalb der Cluster)</span>
linkage_matrix = <span class="function">linkage</span>(data, method=<span class="string">'ward'</span>)

<span class="comment"># Dendrogram visualisieren</span>
plt.<span class="function">figure</span>(figsize=(<span class="number">12</span>, <span class="number">6</span>))
<span class="function">dendrogram</span>(linkage_matrix, truncate_mode=<span class="string">'level'</span>, p=<span class="number">5</span>)
plt.<span class="function">title</span>(<span class="string">'Hierarchisches Clustering - Dendrogram'</span>)
plt.<span class="function">xlabel</span>(<span class="string">'Gemeinden'</span>)
plt.<span class="function">ylabel</span>(<span class="string">'Distanz'</span>)
plt.<span class="function">savefig</span>(<span class="string">'hierarchical_dendrogram.png'</span>)

<span class="comment"># Cluster extrahieren</span>
hierarchical = <span class="function">AgglomerativeClustering</span>(n_clusters=<span class="number">4</span>, linkage=<span class="string">'ward'</span>)
labels_hier = hierarchical.<span class="function">fit_predict</span>(data)
            </div>

            <div class="image-container">
                <img src="4_Cluster/hierarchical_dendrogram.png" alt="Dendrogram">
                <p class="image-caption">Dendrogram: Hierarchische Struktur der Gemeinde-Cluster</p>
            </div>

            <h3>6.3 Gaussian Mixture Model (GMM)</h3>
            <div class="code-block">
<span class="keyword">from</span> sklearn.mixture <span class="keyword">import</span> GaussianMixture

<span class="comment"># GMM mit BIC zur Modellselektion</span>
bic_scores = []
<span class="keyword">for</span> n <span class="keyword">in</span> <span class="function">range</span>(<span class="number">2</span>, <span class="number">11</span>):
    gmm = <span class="function">GaussianMixture</span>(n_components=n, random_state=<span class="number">42</span>)
    gmm.<span class="function">fit</span>(data)
    bic_scores.<span class="function">append</span>(gmm.<span class="function">bic</span>(data))

<span class="comment"># Bestes Modell (niedrigster BIC)</span>
best_n = bic_scores.<span class="function">index</span>(<span class="function">min</span>(bic_scores)) + <span class="number">2</span>

<span class="comment"># Finales GMM</span>
gmm_final = <span class="function">GaussianMixture</span>(n_components=best_n, random_state=<span class="number">42</span>)
labels_gmm = gmm_final.<span class="function">fit_predict</span>(data)
            </div>

            <div class="explanation">
                <div class="explanation-title">Gaussian Mixture Model:</div>
                <p>
                    Im Gegensatz zu K-Means modelliert GMM die Daten als Mischung von
                    Gauss-Verteilungen. Dies erlaubt elliptische (nicht nur sphaerische)
                    Cluster und liefert Wahrscheinlichkeiten fuer die Cluster-Zugehoerigkeit.
                </p>
            </div>

            <h3>6.4 Methodenvergleich</h3>
            <div class="image-container">
                <img src="4_Cluster/cluster_metrics.png" alt="Cluster Metrics">
                <p class="image-caption">Vergleich der Clustering-Metriken verschiedener Methoden</p>
            </div>
        </section>

        <section id="cluster-pca">
            <h2>7. Verbessertes Clustering auf PCA-Scores</h2>

            <p>
                Ein wichtiges Ergebnis unserer Analyse: <strong>Clustering auf den PCA-Scores</strong>
                liefert deutlich bessere Ergebnisse als Clustering auf den rohen 223 Dimensionen.
            </p>

            <div class="highlight-box">
                <h4>Verbesserung durch PCA-basiertes Clustering</h4>
                <table style="color: white; border-color: rgba(255,255,255,0.3);">
                    <tr><th>Ansatz</th><th>Silhouette</th><th>Verbesserung</th></tr>
                    <tr><td>Rohdaten (223 Dim.)</td><td>0.167</td><td>Baseline</td></tr>
                    <tr><td>PCA-Scores (3 Dim.)</td><td>0.335</td><td><strong>+100%</strong></td></tr>
                </table>
            </div>

            <h3>7.1 Clustering auf 3 PCA-Dimensionen</h3>
            <div class="code-block">
<span class="comment"># PCA-Scores laden (bereits berechnet)</span>
pca_scores = pca_df[[<span class="string">'PC1'</span>, <span class="string">'PC2'</span>, <span class="string">'PC3'</span>]].values

<span class="comment"># K-Means auf PCA-Scores</span>
kmeans_pca = <span class="function">KMeans</span>(n_clusters=<span class="number">4</span>, random_state=<span class="number">42</span>, n_init=<span class="number">10</span>)
labels_pca = kmeans_pca.<span class="function">fit_predict</span>(pca_scores)

<span class="comment"># Evaluation</span>
silhouette_pca = <span class="function">silhouette_score</span>(pca_scores, labels_pca)
<span class="function">print</span>(f<span class="string">"Silhouette Score (PCA): {silhouette_pca:.3f}"</span>)
<span class="comment"># Output: Silhouette Score (PCA): 0.335</span>

<span class="comment"># Cluster zuweisen</span>
pca_df[<span class="string">'cluster'</span>] = labels_pca
            </div>

            <div class="explanation">
                <div class="explanation-title">Warum PCA-basiertes Clustering besser funktioniert:</div>
                <ul>
                    <li><strong>Dimensionsreduktion:</strong> Von 223 auf 3 Dimensionen reduziert die Curse of Dimensionality</li>
                    <li><strong>Rauschentfernung:</strong> PCA behaelt nur die wichtigste Varianz, Rauschen wird entfernt</li>
                    <li><strong>Interpretierbarkeit:</strong> Die 3 Dimensionen haben klare politische Bedeutung</li>
                    <li><strong>Kompaktere Cluster:</strong> Im niedrigdimensionalen Raum sind die Cluster besser separiert</li>
                </ul>
            </div>

            <div class="image-container">
                <img src="4_Cluster/pca_cluster_metrics.png" alt="PCA Cluster Metrics">
                <p class="image-caption">Cluster-Metriken fuer PCA-basiertes Clustering</p>
            </div>
        </section>

        <section id="cluster-results">
            <h2>8. Ergebnisse: Die 4 Gemeinde-Cluster</h2>

            <h3>Wichtige Staedte im PCA-Raum</h3>
            <p>Zur Validierung der Achsen-Interpretation hier die PCA-Koordinaten der wichtigsten Schweizer Staedte:</p>
            <table>
                <tr>
                    <th>Gemeinde</th>
                    <th>Cluster</th>
                    <th>PC1<br><small>(Links+ / Rechts-)</small></th>
                    <th>PC2<br><small>(Liberal+ / Konserv.-)</small></th>
                    <th>PC3<br><small>(Oeko.+ / Techn.-)</small></th>
                </tr>
                <tr><td><strong>Zuerich</strong></td><td>Mitte-Liberal</td><td>+16.2</td><td>+4.7</td><td>+15.3</td></tr>
                <tr><td><strong>Geneve</strong></td><td>Links-Kons.</td><td>+20.8</td><td>-5.1</td><td>+8.9</td></tr>
                <tr><td><strong>Basel</strong></td><td>Links-Kons.</td><td>+14.2</td><td>+1.2</td><td>+13.5</td></tr>
                <tr><td><strong>Bern</strong></td><td>Links-Liberal</td><td>+21.0</td><td>+4.5</td><td>+17.1</td></tr>
                <tr><td><strong>Lausanne</strong></td><td>Links-Liberal</td><td>+25.2</td><td>-3.6</td><td>+7.9</td></tr>
                <tr><td><strong>Luzern</strong></td><td>Mitte-Liberal</td><td>+10.8</td><td>+5.6</td><td>+10.9</td></tr>
                <tr><td><strong>St. Gallen</strong></td><td>Mitte-Liberal</td><td>+8.3</td><td>+5.0</td><td>+9.8</td></tr>
                <tr><td><strong>Lugano</strong></td><td>Links-Kons.</td><td>+3.2</td><td>-4.9</td><td>+2.4</td></tr>
                <tr><td><strong>Zug</strong></td><td>Mitte-Liberal</td><td>+2.3</td><td>+10.1</td><td>+3.2</td></tr>
                <tr style="background: #fee;"><td><strong>Muotathal</strong></td><td>Rechts-Kons.</td><td>-26.5</td><td>-8.0</td><td>-7.7</td></tr>
                <tr style="background: #fee;"><td><strong>Schwyz</strong></td><td>Rechts-Kons.</td><td>-9.3</td><td>+1.3</td><td>-0.0</td></tr>
                <tr style="background: #fee;"><td><strong>Appenzell</strong></td><td>Rechts-Kons.</td><td>-9.2</td><td>+5.9</td><td>-2.6</td></tr>
            </table>

            <div class="cluster-card">
                <div class="cluster cluster-0">
                    <h4>Cluster 0: Rechts-Konservativ</h4>
                    <p><strong>683 Gemeinden (32.4%)</strong></p>
                    <p>PC1: -9.4 (Rechts) | PC2: -1.2 (leicht Kons.) | PC3: -0.9</p>
                    <p>Typisch: Laupersdorf, Oberegg, Seelisberg, Buerglen (UR)</p>
                </div>
                <div class="cluster cluster-1">
                    <h4>Cluster 1: Links-Konservativ</h4>
                    <p><strong>330 Gemeinden (15.6%)</strong></p>
                    <p>PC1: +6.7 (Links) | PC2: -7.9 (Kons.) | PC3: +0.6</p>
                    <p>Typisch: Nods, Pery-La Heutte, Soyhieres (Westschweiz)</p>
                </div>
                <div class="cluster cluster-2">
                    <h4>Cluster 2: Mitte-Liberal</h4>
                    <p><strong>719 Gemeinden (34.1%)</strong></p>
                    <p>PC1: -0.4 (Mitte) | PC2: +4.2 (Liberal) | PC3: +3.1</p>
                    <p>Typisch: Thusis, Riedholz, Bueren a.d. Aare, Neuenegg</p>
                </div>
                <div class="cluster cluster-3">
                    <h4>Cluster 3: Links-Liberal</h4>
                    <p><strong>377 Gemeinden (17.9%)</strong></p>
                    <p>PC1: +12.0 (Links) | PC2: +1.1 (Liberal) | PC3: -4.7</p>
                    <p>Typisch: Longirod, Veytaux, Puidoux, Ollon (Waadtland)</p>
                </div>
            </div>

            <h3>8.1 Visualisierungen</h3>

            <p>
                Die folgenden Visualisierungen zeigen alle 2'109 Schweizer Gemeinden im PCA-Raum,
                eingefaerbt nach ihrer Cluster-Zugehoerigkeit. <strong>Wichtige Staedte und typische
                Gemeinden sind beschriftet</strong>, um die Interpretation der Achsen zu erleichtern.
            </p>

            <div class="image-container">
                <img src="4_Cluster/cluster_pc1_pc2.png" alt="Cluster PC1 vs PC2">
                <p class="image-caption">PC1 (Links-Rechts) vs PC2 (Konservativ-Liberal) - X-Achse: Links links, Rechts rechts</p>
            </div>

            <div class="image-grid">
                <div>
                    <img src="4_Cluster/cluster_pc1_pc3.png" alt="Cluster PC1 vs PC3">
                    <p class="image-caption">PC1 vs PC3: Links-Rechts vs Technokratisch-Oekologisch</p>
                </div>
                <div>
                    <img src="4_Cluster/cluster_pc2_pc3.png" alt="Cluster PC2 vs PC3">
                    <p class="image-caption">PC2 vs PC3: Konservativ-Liberal vs Technokratisch-Oekologisch</p>
                </div>
            </div>

            <div class="image-container">
                <img src="4_Cluster/cluster_overview.png" alt="Cluster Overview">
                <p class="image-caption">Uebersicht: Alle drei Projektionen der 4 Cluster</p>
            </div>

            <div class="image-container">
                <img src="4_Cluster/cluster_3d.png" alt="Cluster 3D">
                <p class="image-caption">3D-Visualisierung der Gemeinden im politischen Raum</p>
            </div>

            <h3>8.2 Cluster-Interpretation</h3>
            <div class="explanation">
                <div class="explanation-title">Zusammenfassung der Cluster-Profile:</div>

                <p><strong>Cluster 0 (Rechts-Konservativ):</strong>
                Diese Gemeinden liegen hauptsaechlich in der Innerschweiz und traditionell rechten
                Regionen. Sie zeigen negative PC1-Werte (rechts) und leicht negative PC2-Werte (konservativ).
                Typisch: Muotathal, Schwyz, Appenzell.</p>

                <p><strong>Cluster 1 (Links-Konservativ):</strong>
                Vorwiegend Westschweizer Gemeinden mit positiven PC1-Werten (links) aber stark
                negativen PC2-Werten (konservativ). Diese Kombination ist typisch fuer laendliche
                Westschweizer Gemeinden wie Geneve, Lugano.</p>

                <p><strong>Cluster 2 (Mitte-Liberal):</strong>
                Der groesste Cluster mit Gemeinden nahe der Mitte bei PC1 aber liberal bei PC2.
                Typische Deutschschweizer Staedte wie Zuerich, Luzern, St. Gallen, Zug.</p>

                <p><strong>Cluster 3 (Links-Liberal):</strong>
                Stark links (hohe PC1-Werte) und leicht liberal (positive PC2-Werte).
                Typisch fuer urbane Waadtlaender Gemeinden wie Bern, Lausanne.</p>
            </div>
        </section>

        <footer>
            <p>FFHS Semesterarbeit - Statistische Analyse von Schweizer Abstimmungsdaten</p>
            <p>Erstellt: Januar 2026</p>
        </footer>
    </div>
</body>
</html>
